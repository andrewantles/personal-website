# Blog Build System Plan

## Goals

1. Python build script that converts markdown posts in `/posts/` to HTML pages
   in `/pages/`
2. Auto-generated `/pages/blog.html` landing page listing all posts as
   full-width horizontal tiles, latest first
3. Uses `python-markdown` library for md-to-html conversion
4. Integrates with the component injection system described in `no-js.md`

## What We're Building

```
posts/                                  # You write markdown here
  2024-03-01-google-ml-crash-course.md
  2026-01-18-security-program-week-1.md
  2026-01-25-security-program-week-2.md
  2026-02-01-security-program-week-3.md
  2026-01-25-security-program-week-2-files/   # Post images (source)
  2026-02-01-security-program-week-3-files/   # Post images (source)

src/
  templates/
    post.html                           # HTML wrapper for individual posts
    blog.html                           # Template for the blog listing page
  components/
    header.html
    navbar.html
    footer.html

pages/                                  # Build output
  blog.html                             # Auto-generated listing page
  blog/
    2024-03-01-google-ml-crash-course.html
    2026-01-18-security-program-week-1.html
    ...

public/blog-files/                    # Build output (copied from /posts/)
  2026-01-25-security-program-week-2-files/
  2026-02-01-security-program-week-3-files/
  2024-03-01-google-ml-crash-course/

build.py                                # The build script
```

## Frontmatter: A Gap to Address

Your current markdown files have no metadata header. The build script needs at
least a title and date for each post (to display on the listing page tiles).
Two options:

### Option A: YAML Frontmatter (Recommended)

Add a small metadata block to the top of each markdown file:

```markdown
---
title: "Security Program - Week 3"
date: 2026-02-01
summary: "Booting a Raspberry Pi 4 from USB 3.0 for the home security lab."
---

# Project Mission - North Star
...rest of your post...
```

- `python-markdown` has a built-in `meta` extension that parses this
- The `summary` field is optional but gives you control over what shows on the
  tile (vs auto-extracting the first paragraph)
- This is the standard convention across nearly all blog/markdown systems

### Option B: Parse From Filename + Content

- Date from filename: `2026-02-01-security-program-week-3.md` → `2026-02-01`
- Title from first `# heading` in the file
- Summary from first paragraph

This avoids changing your existing files but is more fragile and gives you less
control.

**Recommendation:** Option A. It's 3-4 lines per file, one-time effort, and
gives you explicit control over how each post appears on the listing page.

## Post Template (`src/templates/post.html`)

Individual blog posts get wrapped in this template during build:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>{{ title }} - AndrewAntles.Net</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../public/style.css">
  </head>
  <body>
    <!-- component:header -->
    <!-- component:navbar -->

    <main class="page-content">
      <article class="blog-post">
        <time datetime="{{ date }}">{{ date_display }}</time>
        {{ content }}
      </article>
    </main>

    <!-- component:footer -->
  </body>
</html>
```

The build script reads this template, replaces `{{ title }}`, `{{ date }}`,
`{{ content }}`, etc., then runs it through the component injector from
`no-js.md`.

## Blog Listing Page (`src/templates/blog.html`)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Blog - AndrewAntles.Net</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../public/style.css">
  </head>
  <body>
    <!-- component:header -->
    <!-- component:navbar -->

    <main class="page-content blog-listing">
      <h2>Blog</h2>
      {{ post_tiles }}
    </main>

    <!-- component:footer -->
  </body>
</html>
```

Each tile is generated by the build script:

```html
<a href="./blog/2026-02-01-security-program-week-3.html" class="post-tile">
  <article>
    <time datetime="2026-02-01">February 1, 2026</time>
    <h3>Security Program - Week 3</h3>
    <p>Booting a Raspberry Pi 4 from USB 3.0 for the home security lab.</p>
  </article>
</a>
```

### Tile Layout & Styling

Full viewport width, stacked vertically, latest first. CSS:

```css
.blog-listing {
  max-width: 720px;  /* matches existing page-content */
}

.post-tile {
  display: block;
  padding: 1.25rem;
  margin-bottom: 1rem;
  background-color: #f0f0f0;
  border-radius: 4px;
  text-decoration: none;
  color: inherit;
  transition: background-color 0.15s;
}

.post-tile:hover,
.post-tile:focus {
  background-color: #e4e4e4;
}

.post-tile time {
  font-size: 0.85em;
  color: #666;
}

.post-tile h3 {
  margin: 0.25em 0;
}

.post-tile p {
  margin: 0;
  color: #555;
}
```

## Build Script Additions (`build.py`)

The build script from `no-js.md` gets extended with:

```python
import markdown  # python-markdown

def parse_frontmatter(text):
    """Extract YAML frontmatter and body from a markdown file."""
    if text.startswith("---"):
        _, fm, body = text.split("---", 2)
        meta = {}
        for line in fm.strip().splitlines():
            key, _, value = line.partition(":")
            meta[key.strip()] = value.strip().strip('"')
        return meta, body.strip()
    return {}, text

def build_posts():
    """Convert markdown posts to HTML pages and generate listing."""
    posts_dir = Path("posts")
    template = (SRC / "templates" / "post.html").read_text()
    components = load_components()
    posts_meta = []

    for md_file in sorted(posts_dir.glob("*.md"), reverse=True):
        raw = md_file.read_text()
        meta, body = parse_frontmatter(raw)

        # Convert markdown to HTML
        html_content = markdown.markdown(body, extensions=["fenced_code"])

        # Fill in the post template
        page = template
        page = page.replace("{{ title }}", meta.get("title", md_file.stem))
        page = page.replace("{{ date }}", meta.get("date", ""))
        page = page.replace("{{ date_display }}", format_date(meta.get("date", "")))
        page = page.replace("{{ content }}", html_content)

        # Inject shared components (header, navbar, footer)
        page = inject_components(page, components)

        # Write to pages/blog/
        dest = Path("pages/blog") / (md_file.stem + ".html")
        dest.parent.mkdir(parents=True, exist_ok=True)
        dest.write_text(page)

        posts_meta.append({
            "title": meta.get("title", md_file.stem),
            "date": meta.get("date", ""),
            "summary": meta.get("summary", ""),
            "slug": md_file.stem,
        })

    # Generate blog listing page
    build_blog_listing(posts_meta, components)
```

## Image Handling

Source images live next to the markdown files in `/posts/`. During build, the
script copies them to a public-facing location so the built HTML can reference
them cleanly.

### How It Works

1. You keep images next to your markdown in `/posts/`:
   ```
   posts/
     2026-02-01-security-program-week-3.md
     2026-02-01-security-program-week-3-files/
       screenshot.png
       network-diagram.png
   ```

2. In your markdown, reference images with relative paths as usual:
   ```markdown
   ![Network diagram](./2026-02-01-security-program-week-3-files/network-diagram.png)
   ```

3. The build script:
   - Scans `/posts/` for image directories (any subdirectory)
   - Copies each directory to `/public/blog-files/<post-slug>/`
   - Creates the destination folder if it doesn't exist
   - Rewrites image `src` paths in the generated HTML to point at the
     public copy

4. Result on disk after build:
   ```
   public/blog-files/
     2026-02-01-security-program-week-3-files/
       screenshot.png
       network-diagram.png
     2024-03-01-google-ml-crash-course/
       revision-history.png
       commit.png
   ```

5. In the built HTML at `pages/blog/2026-02-01-security-program-week-3.html`,
   image tags become:
   ```html
   <img src="../../public/blog-files/2026-02-01-security-program-week-3-files/network-diagram.png"
        alt="Network diagram">
   ```

### Build Script Logic (Conceptual)

```python
import shutil

def copy_post_images():
    """Copy image directories from /posts/ to /public/blog-files/."""
    posts_dir = Path("posts")
    img_dest = Path("public/blog-files")

    for item in posts_dir.iterdir():
        if item.is_dir():
            dest = img_dest / item.name
            if dest.exists():
                shutil.rmtree(dest)  # Clean stale copy
            shutil.copytree(item, dest)

def rewrite_image_paths(html, post_slug):
    """Rewrite relative image paths to point at /public/blog-files/."""
    # Matches src="./some-dir/image.png" or src="some-dir/image.png"
    # Rewrites to src="../../public/blog-files/some-dir/image.png"
    # (../../ because built HTML is at pages/blog/post.html)
    import re
    def replacer(match):
        prefix = match.group(1)  # src=" or src='
        path = match.group(2)
        path = path.lstrip("./")
        return f'{prefix}../../public/blog-files/{path}'
    return re.sub(
        r'(src=["\'])(\./?.+?-files/.+?)(["\'])',
        lambda m: f'{m.group(1)}../../public/blog-files/{m.group(2).lstrip("./")}{m.group(3)}',
        html
    )
```

### Why Copy Instead of Just Rewrite Paths?

- `/posts/` is your authoring space. `/public/` is what the site serves.
  Keeping these roles separate means you could add a `.gitignore` for
  `/public/blog-files/` later if you wanted (build artifact), or not.
- Images co-located with markdown for easy authoring; images in `/public/`
  for clean serving paths.
- The copy is fast (a few images) and idempotent (re-running build refreshes
  everything).

## The Existing Google ML Post

The file `posts/2024-03-01-google-ml-crash-course.md` contains raw HTML, not
markdown. `python-markdown` passes HTML through untouched, so this will
work without changes. However, to use frontmatter and get it on the listing
page, you'd add the `---` block to the top of that file too.

There's also a manually-created HTML version at
`pages/blog-one-post-google-machine-learning.html`. Once the build system
handles this post, that manual file can be removed (or kept as a redirect).

## What `blog-menu.js` Becomes

The current `blog-menu.js` hardcodes a single post link. With this build
system, blog navigation is handled by the listing page (`blog.html`) itself.
The navbar links to `blog.html`, and from there visitors click into individual
posts. `blog-menu.js` can be removed.

If you want per-post navigation (prev/next links), the build script can inject
those since it knows the post order at build time.

## Migration Steps

1. `pip install markdown` (the `python-markdown` library)
2. Add YAML frontmatter to each markdown file in `/posts/`
3. Create `src/templates/post.html` and `src/templates/blog.html`
4. Extend `build.py` with `build_posts()` and `build_blog_listing()`
5. Add blog tile CSS to `public/style.css`
6. Run `python build.py` - verify generated pages look correct
7. Remove `pages/blog-one-post-google-machine-learning.html` (replaced by
   build output)
8. Remove `components/blog-menu.js` (replaced by blog listing page)
9. Commit and push

## Gaps & Questions Identified

1. **Frontmatter:** Your markdown files need metadata. See "Frontmatter"
   section above for the recommended approach. *(In progress - you're
   adding these now.)*

2. **~~Image paths~~:** Resolved. Build script copies images from `/posts/`
   to `/public/blog-files/` and rewrites paths in the generated HTML.

3. **The Google ML post:** It's raw HTML in a `.md` file. Works with
   `python-markdown` but needs frontmatter added for the listing page.

4. **Tile content:** What do you want on each tile beyond title and date?
   The plan assumes: date, title, and a short summary (from frontmatter).
   Let me know if you want something different (e.g., estimated read time,
   tags/categories, a thumbnail image).

5. **Post URL scheme:** The plan uses the markdown filename as the HTML
   filename (`2026-02-01-security-program-week-3.md` →
   `2026-02-01-security-program-week-3.html`). This keeps URLs stable and
   predictable. The existing Google ML post would change URL from
   `blog-one-post-google-machine-learning.html` to
   `2024-03-01-google-ml-crash-course.html`.

6. **Integration with no-js.md:** This plan extends the build script from
   `no-js.md`. Both component injection and post building happen in the same
   `build.py`. Should we implement them together, or blog posts first?

7. **python-markdown extensions:** Beyond `fenced_code` (for code blocks),
   do you want `tables`, `toc` (table of contents), or `codehilite` (syntax
   highlighting)? These are all built-in extensions, zero extra dependencies.
